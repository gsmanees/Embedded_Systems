/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include<stdio.h>
#include <stdint.h>
#include "stm32f446xx.h"
#include "stm32f446xx_spi_driver.h"


/* ---------- GPIO INIT FOR SPI1 ---------- */
void SPI1_GPIO_Init(void)
{
    // Enable GPIOA clock
    RCC->AHB1ENR |= (1 << 0);

    // PA4 (NSS), PA5 (SCK), PA6 (MISO), PA7 (MOSI)
    // Set Alternate Function mode
    GPIOA->MODER &= ~((3 << (4*2)) | (3 << (5*2)) | (3 << (6*2)) | (3 << (7*2)));
    GPIOA->MODER |=  ((2 << (4*2)) | (2 << (5*2)) | (2 << (6*2)) | (2 << (7*2)));

    // Push-pull
    GPIOA->OTYPER &= ~((1 << 4) | (1 << 5) | (1 << 6) | (1 << 7));

    // High speed
    GPIOA->OSPEEDR |= ((3 << (4*2)) | (3 << (5*2)) | (3 << (6*2)) | (3 << (7*2)));

    // No pull-up, no pull-down
    GPIOA->PUPDR &= ~((3 << (4*2)) | (3 << (5*2)) | (3 << (6*2)) | (3 << (7*2)));

    // AF5 for SPI1
    GPIOA->AFR[0] &= ~((0xF << (4*4)) | (0xF << (5*4)) | (0xF << (6*4)) | (0xF << (7*4)));
    GPIOA->AFR[0] |=  ((5 << (4*4)) | (5 << (5*4)) | (5 << (6*4)) | (5 << (7*4)));
}


int main(void)
{

	uint8_t rxByte;
	SPI_Handle_t SPIHandle;

	SPI1_GPIO_Init();

	SPIHandle.pSPIx = SPI1;
	SPIHandle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_SLAVE;
	SPIHandle.SPIConfig.SPI_BusConfig  = SPI_BUS_CONFIG_FD;
	SPIHandle.SPIConfig.SPI_SclkSpeed  = SPI_SCLK_SPEED_DIV2; // ignored in slave
	SPIHandle.SPIConfig.SPI_DFF        = SPI_DFF_8BITS;
	SPIHandle.SPIConfig.SPI_CPOL       = SPI_CPOL_LOW;
	SPIHandle.SPIConfig.SPI_CPHA       = SPI_CPHA_LOW;
	SPIHandle.SPIConfig.SPI_SSM        = SPI_SSM_DI;   // Hardware NSS


	// Init + Enable SPI
	SPI_Init(&SPIHandle);
	SPI_PeripheralControl(SPI1, ENABLE);


	printf("\nSTM32 SPI Slave Ready ..\n\n");


	while (1)
	{

	    SPI_ReceiveData(SPI1, &rxByte, 1);

	   // printf("\nRX: %c (0x%02X)\r\n", rxByte, rxByte);
	    printf("%c", rxByte);

	}



}
